"""
Visitor to transform the ANTLR parse tree into a PytternAST
"""

import ast
import codecs
import re

from .antlr.Python3Parser import Python3Parser
from .antlr.Python3ParserVisitor import Python3ParserVisitor
from .astpyttern import (AstPyttern, StrictMode, AnyBodyWildcard,
                         BodyWildcard, VarWildcard, AnyWildcard, SimpleWildcard, ContainerWildcard)

# Bind operator to their classes
operators = {
    'unary': {
        '+': ast.UAdd,
        '-': ast.USub,
        '~': ast.Invert
    },
    'and': ast.And,
    'or': ast.Or,
    '+': ast.Add,
    '-': ast.Sub,
    '*': ast.Mult,
    '@': ast.MatMult,
    '/': ast.Div,
    '%': ast.Mod,
    '**': ast.Pow,
    '<<': ast.LShift,
    '>>': ast.RShift,
    '|': ast.BitOr,
    '^': ast.BitXor,
    '&': ast.BitAnd,
    '//': ast.FloorDiv,
    '~': ast.Invert,
    'not': ast.Not,
    '==': ast.Eq,
    '!=': ast.NotEq,
    '<': ast.Lt,
    '<=': ast.LtE,
    '>': ast.Gt,
    '>=': ast.GtE,
    'is': ast.Is,
    'is not': ast.IsNot,
    'in': ast.In,
    'not in': ast.NotIn,
    '+=': ast.Add,
    '-=': ast.Sub,
    '*=': ast.Mult,
    '@=': ast.MatMult,
    '/=': ast.Div,
    '%=': ast.Mod,
    '&=': ast.BitAnd,
    '|=': ast.BitOr,
    '^=': ast.BitXor,
    '<<=': ast.LShift,
    '>>=': ast.RShift,
    '**=': ast.Pow,
    '//=': ast.FloorDiv
}


# Handle lineno on PytternAST nodes
def set_lineno(obj, ctx):
    start = ctx.start.line
    end = ctx.stop.line
    if isinstance(obj, (ast.stmt, AstPyttern)):
        obj.lineno = start
        obj.lineno_end = end


class PytternVisitor(Python3ParserVisitor):
    """
    This class defines the visitor to transform the ANTLR parse tree into a PytternAST
    It is a subclass of Python3ParserVisitor, which is generated by ANTLR
    Check https://docs.python.org/3.11/library/ast.html for more information on the AST module
    The Pyttern grammar is defined with ANTLR in antlr/Python3Parser.g4
    """

    def visitMatch_stmt(self, ctx: Python3Parser.Match_stmtContext):
        subject = ctx.subject_expr().accept(self)
        body = []
        cases = ctx.case_block()
        for i, case in enumerate(cases):
            case = cases[i]
            child_result = case.accept(self)
            if child_result is not None:
                if isinstance(child_result, list):
                    body.extend(child_result)
                else:
                    body.append(child_result)
            else:
                print(type(case))

        return ast.Match(subject, body)

    def visitCase_block(self, ctx: Python3Parser.Case_blockContext):
        patterns = ctx.patterns().accept(self)
        guard = ctx.guard().accept(self) if ctx.guard() is not None else None
        body = ctx.block().accept(self)
        return ast.match_case(patterns, guard, body)

    def visitGuard(self, ctx: Python3Parser.GuardContext):
        return ctx.test().accept(self)

    def visitAs_pattern(self, ctx: Python3Parser.As_patternContext):
        or_pattern = ctx.or_pattern().accept(self)
        target = ctx.pattern_capture_target().accept(self)
        return ast.MatchAs(or_pattern, target)

    def visitOr_pattern(self, ctx: Python3Parser.Or_patternContext):
        if len(ctx.closed_pattern()) == 1:
            return ctx.closed_pattern(0).accept(self)

        patterns = list(map(lambda x: x.accept(self), ctx.closed_pattern()))
        return ast.MatchOr(patterns)

    def visitLiteral_pattern(self, ctx: Python3Parser.Literal_patternContext):
        expression = ctx.getChild(0).accept(self)
        return ast.MatchValue(expression)

    def visitCapture_pattern(self, ctx: Python3Parser.Capture_patternContext):
        pat = ctx.pattern_capture_target().accept(self)
        return ast.MatchAs(name=pat)

    def visitWildcard_pattern(self, ctx: Python3Parser.Wildcard_patternContext):
        return ast.MatchAs(None)

    def visitSequence_pattern(self, ctx: Python3Parser.Sequence_patternContext):
        sequence_patterns = ctx.getChild(0,
                                         (Python3Parser.Maybe_sequence_patternContext,
                                          Python3Parser.Open_sequence_patternContext))
        if sequence_patterns is None:
            return ast.MatchSequence()

        patterns = sequence_patterns.accept(self)
        return ast.MatchSequence(patterns)

    def visitMaybe_sequence_pattern(self, ctx: Python3Parser.Maybe_sequence_patternContext):
        maybe_star_patterns = [maybe_start_pattern.accept(self)
                               for maybe_start_pattern in ctx.maybe_star_pattern()]
        return maybe_star_patterns

    def visitStar_pattern(self, ctx: Python3Parser.Star_patternContext):
        name = ctx.getChild(1).accept(self)
        return ast.MatchStar(name)

    def visitName(self, ctx: Python3Parser.NameContext):
        if ctx.UNDERSCORE() is not None:
            return '_'
        return super().visitName(ctx)

    def visitStrings(self, ctx: Python3Parser.StringsContext):
        strings = [self.cleanup_string(s.accept(self)) for s in ctx.STRING()]
        string = ''.join(strings)
        return ast.Constant(string)

    def __init__(self):
        super().__init__()
        self.context = ast.Load()

    def aggregateResult(self, aggregate, next_result):
        if aggregate is None:
            return next_result

        if isinstance(aggregate, list):
            aggregate.append(next_result)
            return aggregate

        if next_result is None:
            return aggregate

        return [aggregate, next_result]

    def visitChildren(self, node):
        children = super().visitChildren(node)
        if not isinstance(children, list):
            set_lineno(children, node)
        return children

    # Visit a parse tree produced by Python3Parser#file_input.
    def visitFile_input(self, ctx: Python3Parser.File_inputContext):
        body = []
        stmts = ctx.stmt()
        for _, stm in enumerate(stmts):
            child_result = stm.accept(self)
            body.append(child_result)

        return ast.Module(body, [])

    # Visit a parse tree produced by Python3Parser#decorator.
    def visitDecorator(self, ctx: Python3Parser.DecoratorContext):
        name = ctx.dotted_name().accept(self)
        if '.' in name:
            name = name.split('.')
            attr = name.pop()
            while len(name) > 0:
                attr = ast.Attribute(ast.Name(name.pop(), self.context), attr, self.context)
            name = attr
        if ctx.OPEN_PAREN() is not None:
            args = ctx.arglist().accept(self) if ctx.arglist() is not None else []
            return ast.Call(name, args, [])
        if isinstance(name, ast.Attribute):
            return name
        return ast.Name(name, self.context)

    # Visit a parse tree produced by Python3Parser#decorators.
    def visitDecorators(self, ctx: Python3Parser.DecoratorsContext):
        return list(map(lambda x: x.accept(self), ctx.decorator()))

    # Visit a parse tree produced by Python3Parser#decorated.
    def visitDecorated(self, ctx: Python3Parser.DecoratedContext):
        decorator = ctx.decorators().accept(self)
        decorated = ctx.getChild(1).accept(self)
        decorated.decorator_list = decorator
        return decorated

    # Visit a parse tree produced by Python3Parser#async_funcdef.
    def visitAsync_funcdef(self, ctx: Python3Parser.Async_funcdefContext):
        funcdef = ctx.funcdef()
        name = funcdef.name().accept(self)
        args = funcdef.parameters().accept(self)
        returns = funcdef.test().accept(self) if funcdef.test() is not None else None
        block = funcdef.block().accept(self)

        return ast.AsyncFunctionDef(name, args, block, [], returns=returns)

    # Visit a parse tree produced by Python3Parser#funcdef.
    def visitFuncdef(self, ctx: Python3Parser.FuncdefContext):
        if ctx.name() is not None:
            name = ctx.name().accept(self)
        elif ctx.simple_wildcard() is not None:
            name = ctx.simple_wildcard().accept(self)
        else:
            name = ctx.var_wildcard().accept(self)
        args = ctx.parameters().accept(self)

        returns = ctx.test().accept(self) if ctx.test() is not None else None

        block = ctx.block().accept(self)

        return ast.FunctionDef(name, args, block, [], returns=returns)

    # Visit a parse tree produced by Python3Parser#parameters.
    def visitParameters(self, ctx: Python3Parser.ParametersContext):
        args = ctx.typedargslist()
        return args.accept(self) if args is not None \
            else ast.arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[])

    # Visit a parse tree produced by Python3Parser#typedargslist.
    def visitTypedargslist(self, ctx: Python3Parser.TypedargslistContext):
        args = []
        defaults = []
        kwonlyargs = []
        kw_defaults = []
        vararg = None
        kwarg = None
        kw = False

        children = list(ctx.getChildren())
        while len(children) > 0:
            child = children.pop(0)
            if type(child).__name__ == 'TfpdefContext':
                kwonlyargs.append(child.accept(self))
                if kw:
                    kw_defaults.append(None)
            elif type(child).__name__ == 'TestContext':
                if kw:
                    kw_defaults.pop()
                kw_defaults.append(child.accept(self))
            elif child.accept(self) == '*':
                kw = True
                vararg = children.pop(0).accept(self)
                if vararg == ',':
                    vararg = None
                args = kwonlyargs[::]
                defaults = kw_defaults[::]
                kwonlyargs = []
                kw_defaults = []

            elif child.accept(self) == '**':
                kwarg = children.pop(0).accept(self)

        if not kw:
            args = kwonlyargs[::]
            defaults = kw_defaults[::]
            kwonlyargs = []
            kw_defaults = []

        return ast.arguments(posonlyargs=[],
                         args=args,
                         vararg=vararg,
                         kwonlyargs=kwonlyargs,
                         kw_defaults=kw_defaults,
                         kwarg=kwarg,
                         defaults=defaults)

    # Visit a parse tree produced by Python3Parser#tfpdef.
    def visitTfpdef(self, ctx: Python3Parser.TfpdefContext):
        if ctx.expr_wildcard() is not None:
            return ctx.expr_wildcard().accept(self)
        val = ctx.name().accept(self)
        type_val = ctx.test().accept(self) if ctx.test() is not None else None
        return ast.arg(val, annotation=type_val)

    # Visit a parse tree produced by Python3Parser#varargslist.
    def visitVarargslist(self, ctx: Python3Parser.VarargslistContext):
        args = []
        defaults = []
        kwonlyargs = []
        kw_defaults = []
        vararg = None
        kwarg = None
        kw = False

        childs = list(ctx.getChildren())
        while len(childs) > 0:
            c = childs.pop(0)
            if type(c).__name__ == 'VfpdefContext':
                kwonlyargs.append(c.accept(self))
                if kw:
                    kw_defaults.append(None)
            elif type(c).__name__ == 'TestContext':
                if kw:
                    kw_defaults.pop()
                kw_defaults.append(c.accept(self))
            elif c.accept(self) == '*':
                kw = True
                vararg = childs.pop(0).accept(self)
                if vararg == ',':
                    vararg = None
                args = kwonlyargs[::]
                defaults = kw_defaults[::]
                kwonlyargs = []
                kw_defaults = []

            elif c.accept(self) == '**':
                kwarg = childs.pop(0).accept(self)

        if not kw:
            args = kwonlyargs[::]
            defaults = kw_defaults[::]
            kwonlyargs = []
            kw_defaults = []

        return ast.arguments(
            posonlyargs=[],
            args=args,
            vararg=vararg,
            kwonlyargs=kwonlyargs,
            kw_defaults=kw_defaults,
            kwarg=kwarg,
            defaults=defaults)

    # Visit a parse tree produced by Python3Parser#vfpdef.
    def visitVfpdef(self, ctx: Python3Parser.VfpdefContext):
        return ast.arg(ctx.name().accept(self))

    # Visit a parse tree produced by Python3Parser#simple_stmt.
    def visitSimple_stmts(self, ctx: Python3Parser.Simple_stmtsContext):
        vals = list(map(lambda x: x.accept(self), ctx.simple_stmt()))
        return vals if len(vals) > 1 else vals[0]

    # Visit a parse tree produced by Python3Parser#expr_stmt.
    def visitExpr_stmt(self, ctx: Python3Parser.Expr_stmtContext):

        if ctx.ASSIGN(0) is not None:
            targets = self.visitChildren(ctx)
            value = targets.pop()
            targets = list(filter(lambda x: x != '=', targets))
            return ast.Assign(targets, value)

        target = ctx.testlist_star_expr(0).accept(self)

        if ctx.annassign() is not None:
            values = ctx.annassign().accept(self)
            if len(values) == 1:
                return ast.AnnAssign(target, values[0])

            return ast.AnnAssign(target, values[0], values[1])

        if ctx.augassign() is not None:
            op = ctx.augassign().accept(self)
            val = ctx.getChild(2).accept(self)
            return ast.AugAssign(target, op, val)

        return ast.Expr(target)

    # Visit a parse tree produced by Python3Parser#annassign.
    def visitAnnassign(self, ctx: Python3Parser.AnnassignContext):
        values = []
        tests = ctx.test()

        for test in tests:
            child_result = test.accept(self)
            values.append(child_result)

        return values

    # Visit a parse tree produced by Python3Parser#testlist_star_expr.
    def visitTestlist_star_expr(self, ctx: Python3Parser.Testlist_star_exprContext):
        values = self.visitChildren(ctx)
        if not isinstance(values, list):
            return values
        values = list(filter(lambda x: x != ',', values))
        return ast.Tuple(values, self.context)

    # Visit a parse tree produced by Python3Parser#augassign.
    def visitAugassign(self, ctx: Python3Parser.AugassignContext):
        operator = ctx.getChild(0).accept(self)
        clazz = operators[operator]

        return clazz()

    # Visit a parse tree produced by Python3Parser#del_stmt.
    def visitDel_stmt(self, ctx: Python3Parser.Del_stmtContext):
        prev_ctx = self.context
        self.context = ast.Del()
        exprs = ctx.exprlist().accept(self)
        if not isinstance(exprs, ast.Tuple):
            exprs = [exprs]
        else:
            exprs = exprs.elts
        self.context = prev_ctx
        return ast.Delete(exprs)

    # Visit a parse tree produced by Python3Parser#pass_stmt.
    def visitPass_stmt(self, ctx: Python3Parser.Pass_stmtContext):
        return ast.Pass()

    # Visit a parse tree produced by Python3Parser#flow_stmt.
    def visitFlow_stmt(self, ctx: Python3Parser.Flow_stmtContext):
        return self.visitChildren(ctx)

    # Visit a parse tree produced by Python3Parser#break_stmt.
    def visitBreak_stmt(self, ctx: Python3Parser.Break_stmtContext):
        return ast.Break()

    # Visit a parse tree produced by Python3Parser#continue_stmt.
    def visitContinue_stmt(self, ctx: Python3Parser.Continue_stmtContext):
        return ast.Continue()

    # Visit a parse tree produced by Python3Parser#return_stmt.
    def visitReturn_stmt(self, ctx: Python3Parser.Return_stmtContext):
        if ctx.testlist() is None:
            return ast.Return()
        value = ctx.testlist().accept(self)
        return ast.Return(value)

    # Visit a parse tree produced by Python3Parser#yield_stmt.
    def visitYield_stmt(self, ctx: Python3Parser.Yield_stmtContext):
        value = ctx.yield_expr().accept(self)
        return ast.Expr(value)

    # Visit a parse tree produced by Python3Parser#raise_stmt.
    def visitRaise_stmt(self, ctx: Python3Parser.Raise_stmtContext):
        tests = ctx.test()
        if len(tests) == 0:
            return ast.Raise()
        exc = tests[0].accept(self)
        if len(tests) == 2:
            cause = tests[1].accept(self)
            return ast.Raise(exc, cause)

        return ast.Raise(exc)

    # Visit a parse tree produced by Python3Parser#import_name.
    def visitImport_name(self, ctx: Python3Parser.Import_nameContext):
        names = ctx.dotted_as_names().accept(self)
        return ast.Import(names)

    # Visit a parse tree produced by Python3Parser#import_from.
    def visitImport_from(self, ctx: Python3Parser.Import_fromContext):
        level = len(ctx.DOT()) + 3 * len(ctx.ELLIPSIS())
        module = ctx.dotted_name().accept(self) if ctx.dotted_name() is not None else None
        import_as = ctx.import_as_names()
        names = import_as.accept(self) if import_as is not None else [ast.alias("*")]
        return ast.ImportFrom(module, names, level)

    # Visit a parse tree produced by Python3Parser#import_as_name.
    def visitImport_as_name(self, ctx: Python3Parser.Import_as_nameContext):
        names = ctx.name()
        name = names[0].accept(self)
        if len(names) == 2:
            al = names[1].accept(self)
            return ast.alias(name, al)
        return ast.alias(name)

    # Visit a parse tree produced by Python3Parser#dotted_as_name.
    def visitDotted_as_name(self, ctx: Python3Parser.Dotted_as_nameContext):
        name = ctx.dotted_name().accept(self)
        asname_node = ctx.name()
        if asname_node is not None:
            asname = asname_node.accept(self)
            return ast.alias(name, asname)
        return ast.alias(name)

    # Visit a parse tree produced by Python3Parser#import_as_names.
    def visitImport_as_names(self, ctx: Python3Parser.Import_as_namesContext):
        return list(map(lambda x: x.accept(self), ctx.import_as_name()))

    # Visit a parse tree produced by Python3Parser#dotted_as_names.
    def visitDotted_as_names(self, ctx: Python3Parser.Dotted_as_namesContext):
        return list(map(lambda x: x.accept(self), ctx.dotted_as_name()))

    # Visit a parse tree produced by Python3Parser#dotted_name.
    def visitDotted_name(self, ctx: Python3Parser.Dotted_nameContext):
        names = list(map(lambda x: x.accept(self), ctx.name()))
        return '.'.join(names)

    # Visit a parse tree produced by Python3Parser#global_stmt.
    def visitGlobal_stmt(self, ctx: Python3Parser.Global_stmtContext):
        names = []
        name = ctx.name()
        for child in name:
            child_result = child.accept(self)
            names.append(child_result)

        return ast.Global(names)

    # Visit a parse tree produced by Python3Parser#nonlocal_stmt.
    def visitNonlocal_stmt(self, ctx: Python3Parser.Nonlocal_stmtContext):
        names = []
        name = ctx.name()
        for child in name:
            child_result = child.accept(self)
            names.append(child_result)

        return ast.Nonlocal(names)

    # Visit a parse tree produced by Python3Parser#assert_stmt.
    def visitAssert_stmt(self, ctx: Python3Parser.Assert_stmtContext):
        tests = ctx.test()
        test = tests[0].accept(self)
        if len(tests) == 2:
            msg = tests[1].accept(self)
            return ast.Assert(test, msg)
        return ast.Assert(test)

    # Visit a parse tree produced by Python3Parser#if_stmt.
    def visitIf_stmt(self, ctx: Python3Parser.If_stmtContext):
        tests = ctx.test()
        blocks = ctx.block()
        if len(blocks) > len(tests):
            cur_block = blocks.pop().accept(self)
        else:
            cur_block = []
        while len(tests) > 0:
            cur_test = tests.pop().accept(self)
            body = blocks.pop().accept(self)
            ifstmt = ast.If(cur_test, body, cur_block)
            cur_block = [ifstmt]

        return cur_block[0]

    # Visit a parse tree produced by Python3Parser#while_stmt.
    def visitWhile_stmt(self, ctx: Python3Parser.While_stmtContext):
        test = ctx.test().accept(self)
        block = ctx.block(0).accept(self)

        if getattr(ctx, "ELSE")() is None:
            return ast.While(test, block, [])

        else_body = ctx.block(1).accept(self)
        return ast.While(test, block, else_body)

    # Visit a parse tree produced by Python3Parser#for_stmt.
    def visitFor_stmt(self, ctx: Python3Parser.For_stmtContext):
        target = ctx.exprlist().accept(self)
        ite = ctx.testlist().accept(self)
        body = ctx.block(0).accept(self)
        orelse = ctx.block(1).accept(self) if ctx.block(1) is not None else []
        return ast.For(target, ite, body, orelse)

    # Visit a parse tree produced by Python3Parser#try_stmt.
    def visitTry_stmt(self, ctx: Python3Parser.Try_stmtContext):
        """
        Visit a parse tree produced by Python3Parser#try_stmt.

        Extracts the try statement's body and exception handlers from the parse tree
        and creates a Try object with these components.

        Args:
            ctx (Python3Parser.Try_stmtContext): The parse tree context for the try statement.

        Returns:
            Try: A Try object with the try statement's body, exception handlers, else block,
            and finally block.
        """
        # Extract the try statement's body and exception handlers from the parse tree
        blocks = ctx.block()
        blocks.reverse()
        body = blocks.pop().accept(self)

        handlers = []
        clauses = ctx.except_clause()
        # Extract each exception handler and its body
        for child in clauses:
            child_result = child.accept(self)
            handler = child_result
            handler.body = blocks.pop().accept(self)
            handlers.append(handler)

        # Check if there are any exception handlers
        if len(handlers) == 0:
            # If not, check if there is a final block
            final = blocks.pop().accept(self)
            return ast.Try(body, handlers, [], final)

        # If there are exception handlers, check if there is an else block
        if len(blocks) == 0:
            return ast.Try(body, handlers, [], [])

        next_body = blocks.pop().accept(self)
        # If there is an else block, extract it
        if getattr(ctx, "ELSE")() is None:
            return ast.Try(body, handlers, [], next_body)
        # If there is no else block, check if there is a finally block

        if ctx.FINALLY() is None:
            return ast.Try(body, handlers, next_body, [])

        # If there is both an else and finally block, extract the finally block
        final_body = blocks.pop().accept(self)
        return ast.Try(body, handlers, next_body, final_body)

    # Visit a parse tree produced by Python3Parser#with_stmt.
    def visitWith_stmt(self, ctx: Python3Parser.With_stmtContext):
        items = list(map(lambda x: x.accept(self), ctx.with_item()))
        body = ctx.block().accept(self)
        return ast.With(items, body)

    # Visit a parse tree produced by Python3Parser#with_item.
    def visitWith_item(self, ctx: Python3Parser.With_itemContext):
        ctx_expr = ctx.test().accept(self)
        if ctx.expr() is None:
            return ast.withitem(ctx_expr)

        opt_vars = ctx.expr().accept(self)
        return ast.withitem(ctx_expr, opt_vars)

    # Visit a parse tree produced by Python3Parser#except_clause.
    def visitExcept_clause(self, ctx: Python3Parser.Except_clauseContext):
        if ctx.test() is None:
            return ast.ExceptHandler()

        test = ctx.test().accept(self)
        if ctx.name() is None:
            return ast.ExceptHandler(test)

        name = ctx.name().accept(self)
        return ast.ExceptHandler(test, name)

    # Visit a parse tree produced by Python3Parser#block.
    def visitBlock(self, ctx: Python3Parser.BlockContext):
        if ctx.simple_stmts() is not None:
            stmts = ctx.simple_stmts().accept(self)
            return stmts if isinstance(stmts, list) else [stmts]

        body = []
        stmts = ctx.stmt()
        for i in range(len(stmts)):
            c = stmts[i]
            child_result = c.accept(self)
            if child_result is not None:
                if isinstance(child_result, list):
                    body.extend(child_result)
                else:
                    body.append(child_result)
            else:
                print(type(c))

        return body

    # Visit a parse tree produced by Python3Parser#tests.
    def visitTest(self, ctx: Python3Parser.TestContext):
        if getattr(ctx, "IF")() is not None:
            body = ctx.or_test(0).accept(self)
            test = ctx.or_test(1).accept(self)
            orelse = ctx.test().accept(self)
            return ast.IfExp(test, body, orelse)

        return self.visitChildren(ctx)

    # Visit a parse tree produced by Python3Parser#lambdef.
    def visitLambdef(self, ctx: Python3Parser.LambdefContext):
        args = ctx.varargslist()
        args = args.accept(self) if args is not None else ast.arguments([], [], None, [], [], None, [])
        body = ctx.test().accept(self)
        return ast.Lambda(args, body)

    # Visit a parse tree produced by Python3Parser#lambdef_nocond.
    def visitLambdef_nocond(self, ctx: Python3Parser.Lambdef_nocondContext):
        args = ctx.varargslist().accept(self)
        body = ctx.test_nocond().accept(self)
        return ast.Lambda(args, body)

    # Visit a parse tree produced by Python3Parser#or_test.
    def visitOr_test(self, ctx: Python3Parser.Or_testContext):
        ors = ctx.and_test()
        n = len(ors)
        if n == 1:
            return self.visitChildren(ctx)

        vals = list(map(lambda x: x.accept(self), ors))
        return ast.BoolOp(ast.Or(), vals)

    # Visit a parse tree produced by Python3Parser#and_test.
    def visitAnd_test(self, ctx: Python3Parser.And_testContext):
        ands = ctx.not_test()
        n = len(ands)
        if n == 1:
            return self.visitChildren(ctx)

        vals = list(map(lambda x: x.accept(self), ands))
        return ast.BoolOp(ast.And(), vals)

    # Visit a parse tree produced by Python3Parser#not_test.
    def visitNot_test(self, ctx: Python3Parser.Not_testContext):
        test = ctx.not_test()
        if test is None:
            return self.visitChildren(ctx)
        return ast.UnaryOp(ast.Not(), test.accept(self))

    # Visit a parse tree produced by Python3Parser#comparison.
    def visitComparison(self, ctx: Python3Parser.ComparisonContext):
        exprs = ctx.expr()
        if len(exprs) == 1:
            return self.visitChildren(ctx)

        tests = ctx.comp_op()
        test = []
        expr = []
        n = len(tests)
        for i in range(n):
            c = tests[i]
            child_result = c.accept(self)
            test.append(child_result)

            c = exprs[i + 1]
            child_result = c.accept(self)
            expr.append(child_result)

        left = exprs[0].accept(self)

        return ast.Compare(left, test, expr)

    # Visit a parse tree produced by Python3Parser#comp_op.
    def visitComp_op(self, ctx: Python3Parser.Comp_opContext):
        op = self.visitChildren(ctx)
        if isinstance(op, list):
            op = ' '.join(op)
        clazz = operators[op]

        return clazz()

    # Visit a parse tree produced by Python3Parser#expr.
    def visitExpr(self, ctx: Python3Parser.ExprContext):
        if ctx.atom_expr() is not None:
            return ctx.atom_expr().accept(self)

        if ctx.getChildCount() == 1:
            return self.visitChildren(ctx)

        exprs = ctx.expr()
        if len(exprs) > 1:
            left = ctx.getChild(0).accept(self)
            op_sign = ctx.getChild(1).accept(self)
            op = operators.get(op_sign)()
            right = ctx.getChild(2).accept(self)

            return ast.BinOp(left, op, right)

        children = list(ctx.getChildren())
        expr = children.pop()
        operand = expr.accept(self)
        while len(children) > 0:
            op_sign = children.pop().accept(self)
            op = operators.get('unary').get(op_sign)()
            operand = ast.UnaryOp(op, operand)

        return operand

    # Visit a parse tree produced by Python3Parser#atom_expr.
    def visitAtom_expr(self, ctx: Python3Parser.Atom_exprContext):
        ret = ctx.atom().accept(self)

        trailers = ctx.trailer()
        for i in range(len(trailers)):
            trail = trailers[i].accept(self)

            if isinstance(trail, ast.Call):
                trail.func = ret
                ret = trail
            else:
                trail.value = ret
                ret = trail

        return ret

    @staticmethod
    def replace_escaped_chars(string):
        # Define a dictionary mapping escaped characters to their corresponding values
        escape_dict = {
            "\\n": "\n",
            "\\r": "\r",
            "\\t": "\t",
            "\\\\": "\\",
            "\\'": "'",
            '\\"': '"'
            # Add more escape sequences here as needed
        }
        # Create a regular expression pattern that matches any escaped character
        escape_pattern = re.compile("|".join(re.escape(key) for key in escape_dict.keys()))
        # Replace all escaped characters with their corresponding values
        return escape_pattern.sub(lambda match: escape_dict[match.group()], string)

    @staticmethod
    def transform_string_to_byte(input_str):
        try:
            # Use eval to interpret the input string as a Python literal
            value = eval(input_str)

            # Check if the value is a bytes-like object (bytes or bytearray)
            if isinstance(value, (bytes, bytearray)):
                # Convert the value to a formatted byte string
                formatted_bytes = b"".join([bytes([byte]) for byte in value])
                return formatted_bytes

            raise ValueError("Input string is not a valid bytes literal.")
        except Exception as e:
            raise ValueError("Error transforming the input string to a byte string.") from e

    @staticmethod
    def convert_escape_sequence(input_string):
        # Decode the string using 'unicode_escape' codec
        output_string = codecs.decode(input_string, 'unicode_escape')
        return output_string

    def cleanup_string(self, string):
        # remove potential '\' at the end of each line
        regex = r"\\\n"
        string = re.sub(regex, "", string, 0, re.MULTILINE)

        if string.startswith('"""') or string.startswith("'''"):
            string = string[3:-3]
            string = self.replace_escaped_chars(string)
        elif string.startswith('"') or string.startswith("'"):
            string = string[1:-1]
            if "\\x" in string:
                string = self.convert_escape_sequence(string)
            string = self.replace_escaped_chars(string)
        elif string.startswith('b'):
            string = self.transform_string_to_byte(string.encode())
        elif string.startswith('r'):
            string = string[2:-1]

        return string

    # Visit a parse tree produced by Python3Parser#atom.
    def visitAtom(self, ctx: Python3Parser.AtomContext):
        if ctx.name() is not None:
            return ast.Name(ctx.name().accept(self), self.context)

        if ctx.NUMBER() is not None:
            num = ctx.NUMBER().accept(self).lower()
            if '.' in num or 'e' in num:
                return ast.Constant(float(num))
            base = 10
            if len(num) > 2 and num[0] == '0':
                b = num[1]
                if b == 'b':
                    base = 2
                elif b == 'o':
                    base = 8
                elif b == 'x':
                    base = 16
            return ast.Constant(int(num, base))

        if len(ctx.STRING()) > 0:
            if len(ctx.STRING()) == 1:
                string = ctx.STRING(0).accept(self)
                string = self.cleanup_string(string)
            else:
                strings = [self.cleanup_string(s.accept(self)) for s in ctx.STRING()]
                string = ''.join(strings)

            return ast.Constant(string)

        if ctx.ELLIPSIS() is not None:
            return ast.Constant(...)

        if ctx.NONE() is not None:
            return ast.Constant(None)

        if ctx.TRUE() is not None:
            return ast.Constant(True)

        if ctx.FALSE() is not None:
            return ast.Constant(False)

        if ctx.OPEN_PAREN() is not None:
            if ctx.testlist_comp() is not None:
                val = ctx.testlist_comp().accept(self)
                if isinstance(val, ast.List):
                    val = val.elts
                elif isinstance(val, ast.ListComp):
                    return ast.GeneratorExp(elt=val.elt, generators=val.generators)
            elif ctx.yield_expr() is not None:
                val = ctx.yield_expr().accept(self)
            else:
                val = []
            if isinstance(val, list):
                return ast.Tuple(elts=val, ctx=self.context)
            return val

        if ctx.OPEN_BRACK() is not None:
            val = ctx.testlist_comp().accept(self) if ctx.testlist_comp() is not None \
                else ast.List(elts=[], ctx=self.context)
            if not isinstance(val, ast.List) and not isinstance(val, ast.ListComp):
                val = ast.List(elts=[val], ctx=self.context)
            return val

        if ctx.OPEN_BRACE() is not None:
            val = ctx.dictorsetmaker().accept(self) if ctx.dictorsetmaker() is not None \
                else ast.Dict(keys=[], values=[])
            return val

        return self.visitChildren(ctx)

    # Visit a parse tree produced by Python3Parser#testlist_comp.
    def visitTestlist_comp(self, ctx: Python3Parser.Testlist_compContext):
        if ctx.comp_for() is not None:
            comp = ctx.comp_for().accept(self)
            elt = ctx.getChild(0).accept(self)
            return ast.ListComp(elt=elt, generators=comp)
        vals = self.visitChildren(ctx)
        if isinstance(vals, list):
            vals = list(filter(lambda x: x != ',', vals))
            return ast.List(elts=vals, ctx=self.context)
        return vals

    # Visit a parse tree produced by Python3Parser#trailer.
    def visitTrailer(self, ctx: Python3Parser.TrailerContext):
        prev_ctx = self.context
        self.context = ast.Load()
        if ctx.subscriptlist() is not None:
            val = ctx.subscriptlist().accept(self)
            return ast.Subscript(value=None, slice=val, ctx=self.context)

        if ctx.name() is not None:
            val = ctx.name().accept(self)
            return ast.Attribute(value=None, attr=val, ctx=self.context)

        if ctx.arglist() is not None:
            allargs = ctx.arglist().accept(self)

            # Filter args and keywords
            keywords = list(filter(lambda x: isinstance(x, ast.keyword), allargs))
            args = list(filter(lambda x: x not in keywords, allargs))

            return ast.Call(args=args, keywords=keywords)

        return ast.Call(args=[], keywords=[])

    # Visit a parse tree produced by Python3Parser#subscriptlist.
    def visitSubscriptlist(self, ctx: Python3Parser.SubscriptlistContext):
        prev_ctx = self.context
        self.context = ast.Load()
        if ctx.getChildCount() > 1:
            subscriptlist = list(map(lambda x: x.accept(self), ctx.subscript_()))
            self.context = prev_ctx
            return ast.Tuple(subscriptlist, self.context)

        subscript = ctx.subscript_(0).accept(self)
        self.context = prev_ctx
        return subscript

    # Visit a parse tree produced by Python3Parser#subscript.
    def visitSubscript_(self, ctx: Python3Parser.Subscript_Context):
        if ctx.COLON() is not None:
            lower = None
            step = ctx.sliceop().accept(self) if ctx.sliceop() is not None else None

            if ctx.getChild(0) == ctx.test(0):
                lower = ctx.test(0).accept(self)
                upper = ctx.test(1).accept(self) if len(ctx.test()) > 1 else None
            else:
                upper = ctx.test(0).accept(self) if len(ctx.test()) > 0 else None

            return ast.Slice(lower=lower, upper=upper, step=step)

        return self.visitChildren(ctx)

    # Visit a parse tree produced by Python3Parser#exprlist.
    def visitExprlist(self, ctx: Python3Parser.ExprlistContext):
        vals = self.visitChildren(ctx)
        if isinstance(vals, list):
            vals = list(filter(lambda x: x != ',', vals))
            return ast.Tuple(elts=vals, ctx=self.context)
        return vals

    # Visit a parse tree produced by Python3Parser#testlist.
    def visitTestlist(self, ctx: Python3Parser.TestlistContext):
        vals = list(map(lambda x: x.accept(self), ctx.test()))
        return ast.Tuple(vals, self.context) if len(vals) > 1 else vals[0]

    # Visit a parse tree produced by Python3Parser#dictorsetmaker.
    def visitDictorsetmaker(self, ctx: Python3Parser.DictorsetmakerContext):
        if len(ctx.COLON()) > 0:
            # we have a dict
            if ctx.comp_for() is not None:
                # we have a dict comprehension
                comp = ctx.comp_for().accept(self)
                keys = ctx.test(0).accept(self)
                values = ctx.test(1).accept(self)
                return ast.DictComp(key=keys, value=values, generators=comp)

            tests = list(map(lambda x: x.accept(self), ctx.test()))
            keys = tests[::2]
            values = tests[1::2]
            return ast.Dict(keys=keys, values=values)

        # we have a set
        if ctx.comp_for() is not None:
            # we have a set comprehension
            comp = ctx.comp_for().accept(self)
            elt = ctx.test(0).accept(self)
            return ast.SetComp(elt=elt, generators=comp)

        vals = self.visitChildren(ctx)
        if not isinstance(vals, list):
            vals = [vals]
        else:
            vals = list(filter(lambda x: x != ',', vals))
        return ast.Set(elts=vals)

    # Visit a parse tree produced by Python3Parser#classdef.
    def visitClassdef(self, ctx: Python3Parser.ClassdefContext):
        if ctx.name() is not None:
            name = ctx.name().accept(self)
        elif ctx.simple_wildcard() is not None:
            name = ctx.simple_wildcard().accept(self)
        else:
            name = ctx.var_wildcard().accept(self)
        args = ctx.arglist()
        args = args.accept(self) if args is not None else []
        body = ctx.block().accept(self)
        return ast.ClassDef(name, args, [], body, [])

    # Visit a parse tree produced by Python3Parser#arglist.
    def visitArglist(self, ctx: Python3Parser.ArglistContext):
        return list(map(lambda x: x.accept(self), ctx.argument()))

    # Visit a parse tree produced by Python3Parser#argument.
    def visitArgument(self, ctx: Python3Parser.ArgumentContext):
        if ctx.STAR() is not None:
            return ast.Starred(value=ctx.test(0).accept(self), ctx=self.context)

        if ctx.POWER() is not None:
            return ast.keyword(value=ctx.test(0).accept(self))

        if ctx.ASSIGN() is not None:
            key = ctx.test(0).accept(self)
            key = key.id if isinstance(key, ast.Name) else key.value
            return ast.keyword(arg=key, value=ctx.test(1).accept(self))

        if ctx.comp_for() is not None:
            generator = ctx.comp_for().accept(self)
            elt = ctx.test(0).accept(self)
            return ast.GeneratorExp(elt=elt, generators=generator)

        return self.visitChildren(ctx)

    # Visit a parse tree produced by Python3Parser#comp_iter.
    def visitComp_iter(self, ctx: Python3Parser.Comp_iterContext):
        vals = self.visitChildren(ctx)
        return vals

    # Visit a parse tree produced by Python3Parser#comp_for.
    def visitComp_for(self, ctx: Python3Parser.Comp_forContext):
        target = ctx.exprlist().accept(self)
        iter_val = ctx.or_test().accept(self)
        is_async = 1 if ctx.ASYNC() is not None else 0

        ret = []
        ifs = []
        next_comp = ctx.comp_iter()
        if next_comp is not None:
            next_comp = next_comp.accept(self)
            for comp in next_comp:
                if isinstance(comp, ast.comprehension):
                    ret.append(comp)
                else:
                    ifs.append(comp)
        return [ast.comprehension(target=target, iter=iter_val, ifs=ifs, is_async=is_async)] + ret

    # Visit a parse tree produced by Python3Parser#comp_if.
    def visitComp_if(self, ctx: Python3Parser.Comp_ifContext):
        test = ctx.test_nocond().accept(self)
        next_comp = ctx.comp_iter().accept(self) if ctx.comp_iter() is not None else []

        return [test] + next_comp

    # Visit a parse tree produced by Python3Parser#yield_expr.
    def visitYield_expr(self, ctx: Python3Parser.Yield_exprContext):
        if ctx.yield_arg() is not None:
            return ctx.yield_arg().accept(self)
        return ast.Yield(None)

    # Visit a parse tree produced by Python3Parser#yield_arg.
    def visitYield_arg(self, ctx: Python3Parser.Yield_argContext):
        if ctx.FROM() is not None:
            return ast.YieldFrom(ctx.test().accept(self))
        return ast.Yield(ctx.testlist().accept(self))

    def visitTerminal(self, node):
        txt = node.getText()
        if txt.isspace():
            return None
        return txt

    def visitWildcard_type(self, ctx: Python3Parser.Wildcard_typeContext):
        return list(map(lambda x: x.accept(self), ctx.name()))

    def visitWildcard_number(self, ctx: Python3Parser.Wildcard_numberContext):
        low = ctx.NUMBER(0).accept(self)
        high = low
        if ctx.NUMBER(1) is not None:
            high = ctx.NUMBER(1).accept(self)
            if high < low:
                raise ValueError("High must be bigger than low")
        elif ctx.COMMA() is not None:
            high = 2e64
        return int(low), int(high)

    # Visit a parse tree produced by Python3Parser#simple_wildcard.
    def visitSimple_wildcard(self, ctx: Python3Parser.Simple_wildcardContext):
        types = None
        if ctx.wildcard_type() is not None:
            types = ctx.wildcard_type().accept(self)
        numbers = (1, 1)
        if ctx.wildcard_number() is not None:
            numbers = ctx.wildcard_number().accept(self)
        if numbers == (0, 0):
            ast_types = [t for t in ast.__dir__() if t[0].isupper()]
            ast_types = [t for t in ast_types if t not in types]
            wildcard = AnyWildcard(ast_types)
            set_lineno(wildcard, ctx)
            return wildcard
        wildcard = SimpleWildcard(types, numbers[0], numbers[1])
        set_lineno(wildcard, ctx)
        return wildcard

    # Visit a parse tree produced by Python3Parser#double_wildcard.
    def visitDouble_wildcard(self, ctx: Python3Parser.Double_wildcardContext):
        types = None
        if ctx.wildcard_type() is not None:
            types = ctx.wildcard_type().accept(self)
        wildcard = AnyWildcard(types)
        set_lineno(wildcard, ctx)
        return wildcard

    def visitVar_wildcard(self, ctx: Python3Parser.Var_wildcardContext):
        types = None
        if ctx.wildcard_type() is not None:
            types = ctx.wildcard_type().accept(self)
        name = ctx.name().accept(self)
        wildcard = VarWildcard(name, types)
        set_lineno(wildcard, ctx)
        return wildcard

    def visitContains_wildcard(self, ctx: Python3Parser.Contains_wildcardContext):
        types = None
        if ctx.wildcard_type() is not None:
            types = ctx.wildcard_type().accept(self)
        value = ctx.getChild(2).accept(self)
        if isinstance(value, ast.Expr):
            value = value.value
        wildcard = ContainerWildcard(value, types)
        set_lineno(wildcard, ctx)
        return wildcard

    def visitSimple_compound_wildcard(self, ctx: Python3Parser.Simple_compound_wildcardContext):
        types = None
        if ctx.wildcard_type() is not None:
            types = ctx.wildcard_type().accept(self)
        numbers = (1, 1)
        if ctx.wildcard_number() is not None:
            numbers = ctx.wildcard_number().accept(self)
        body = ctx.block().accept(self)
        if numbers == (0, 0):
            ast_types = [t for t in ast.__dir__() if t[0].isupper()]
            ast_types = [t for t in ast_types if t not in types]
            wildcard = AnyBodyWildcard(body, ast_types)
            set_lineno(wildcard, ctx)
            return wildcard
        wildcard = BodyWildcard(body, types, numbers[0], numbers[1])
        set_lineno(wildcard, ctx)
        return wildcard

    def visitMultiple_compound_wildcard(self, ctx: Python3Parser.Multiple_compound_wildcardContext):
        types = None
        if ctx.wildcard_type() is not None:
            types = ctx.wildcard_type().accept(self)
        body = ctx.block().accept(self)
        wildcard = AnyBodyWildcard(body, types)
        set_lineno(wildcard, ctx)
        return wildcard

    def visitStrict_mode(self, ctx: Python3Parser.Strict_modeContext):
        body = self.visitChildren(ctx)
        wildcard = StrictMode(body, True)
        set_lineno(wildcard, ctx)

        end_wildcard = StrictMode(None, False)
        set_lineno(wildcard, ctx)
        return [wildcard, end_wildcard]